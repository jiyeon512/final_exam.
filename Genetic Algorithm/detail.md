1. 소개
유전 알고리즘은 생물체가 환경에 적응하면서 진화해가는 모습을 모방하여 최적해를 찾아내는 검색 방법이다. 
유전 알고리즘은 이론적으로 전역 최적점을 찾을 수 있으며, 수학적으로 명확하게 정의되지 않은 문제에도 적용할 수 있기 때문에 매우 유용하게 이용된다.
일반적으로 유전 알고리즘에 대해 알고리즘이라는 표현을 이용하지만, 유전 알고리즘은 특정한 문제를 풀기 위한 알고리즘이라기 보다는 최적화 문제를 풀기 위한 방법론에 가깝다. 
즉, 모든 문제에 적용 가능한 하나의 알고리즘이나 소스 코드가 있는 것이 아니기 때문에 유전 알고리즘의 원리를 이해하고, 이를 자신이 원하는 문제에 적용할 수 있도록 하는 것이 중요하다. 
유전 알고리즘을 정의하기 위해 아래와 같은 개념들을 정의한다.

• 염색체 (chromosome): 생물학적으로는 유전 물질을 담고 있는 하나의 집합을 의미하며, 유전 알고리즘에는 하나의 해 (solution)를 표현한다. 

• 유전자 (gene): 염색체를 구성하는 요소로써, 하나의 유전 정보를 나타낸다. 어떠한 염색체가 [A B C]라면, 이 염색체에는 각각 A, B 그리고 C의 값을 갖는 3개의 gene이 존재한다.

• 자손 (offspring): 특정 시간 t에 존재했던 염색체들로부터 생성된 염색체를 t에 존재했던 염색체들의 자손이라고 한다. 자손은 이전 세대와 비슷한 유전 정보를 갖는다.

• 적합도 (fitness): 어떠한 염색체가 갖고 있는 고유값으로써, 해당 문제에 대해 염색체가 표현하는 해가 얼마나 적합한지를 나타낸다.


2. 알고리즘 구조
유전 알고리즘은 t에 존재하는 염색체들의 집합으로부터 적합도가 가장 좋은 염색체를 선택하고, 선택된 해의 방향으로 검색을 반복하면서 최적해를 찾아가는 구조로 동작한다. 
유전 알고리즘의 동작을 단계별로 표현하면 아래와 같다.

1) 초기 염색체의 집합 생성

2) 초기 염색체들에 대한 적합도 계산

3) 현재 염색체들로부터 자손들을 생성

4) 생성된 자손들의 적합도 계산

5) 종료 조건 판별

6-1) 종료 조건이 거짓인 경우, (3)으로 이동하여 반복

6-2) 종료 조건이 참인 경우, 알고리즘을 종료


유전 알고리즘의 구조는 매우 간단하다. 그러나 (3)의 자손들을 생성하는 단계에서 알고리즘의 성능을 향상시키기 위한 몇가지 기법들이 적용되기 때문에 다음 항목에서 이러한 기법들에 설명한다.


3. 연산 정의
유전 알고리즘을 어떠한 문제에 적용하기 위해서는 총 5개의 아래와 같은 연산을 정의해야 한다.


• 초기 염색체를 생성하는 연산

• 적합도를 계산하는 연산

• 적합도를 기준으로 염색체를 선택하는 연산

• 선택된 염색체들로부터 자손을 생성하는 연산

• 돌연변이 (mutation) 연산

각각의 연산에 대해서는 아래에 자세히 설명한다. 그러나 아래의 설명은 유전 알고리즘에서 일반적으로 이용되는 하나의 예시일뿐이며, 필요에 따라서는 해결하고자 하는 문제에 맞는 연산으로 대체할 수 있다.


3.1. 초기 염색체 생성 연산

초기에는 이전 염색체가 존재하지 않기 때문에 선택된 염색체들로부터 자손을 생성할 수가 없다. 따라서, 초기 염색체를 생성하는 연산을 별도로 정의해야 한다. 유전 알고리즘에서 가장 많이 이용되는 방법은 어떠한 규칙도 없이 단순히 임의의 값으로 염색체를 생성하는 것이다. 예를 들어, 자바로 작성된 [코드 1]과 같은 소스 코드는 유전 알고리즘의 초기 염색체 생성 연산으로 이용될 수 있다.

![image](https://user-images.githubusercontent.com/101514626/173854403-ba7403b1-a332-41a3-ad5a-e16ecca7cb73.png)

[코드 1] 초기 염색체 생성 연산의 예시.

[코드 1]에서는 어떠한 염색체에 단순히 [0, MAX_VAL_GENE) 사이의 값을 임의로 할당하고 있다.


3.2. 적합도를 계산하는 연산

염색체에 표현된 정보를 기반으로 적합도를 계산하는 연산이다. 이 연산은 해결하고자 하는 문제에 매우 종속적이다.


3.3. 적합도를 기준으로 염색체를 선택하는 연산

자손을 생성하기 위한 두 개의 부모 염색체를 선택할 때는 단순히 적합도가 가장 높은 두 개의 염색체를 선택할 수도 있다. 그러나 이러한 방법은 염색체의 다양성을 크게 훼손시키기 때문에 전역 최적해를 찾기에는 부적합하다.

이러한 문제점을 해결하기 위해 유전 알고리즘에서는 일반적으로 룰렛 휠 선택 (roulette wheel selection) 방법을 이용한다. 룰렛 휠 선택의 개념은 매우 간단하다. 어떠한 염색체를 아래의 [식 1]과 같이 정의된 P(Chi)를 바탕으로 확률적으로 선택하는 것이 룰렛 휠 선택이다. [식 1]에서 N은 염색체의 수이고, f는 염색체의 적합도를 구하는 함수이다.

![image](https://user-images.githubusercontent.com/101514626/173855027-0bcfddb3-60ac-47de-abf0-2ee290e16a2f.png)

[식 1]로 표현되는 룰렛 휠 선택을 그림으로 표현하면 아래의 [그림 1]과 같다.

![image](https://user-images.githubusercontent.com/101514626/173855241-67328c32-9ce6-41eb-8d22-ed8d7e640a65.png)

[그림 1] 룰렛 휠 선택 (Roulette wheel selection)의 개념.


즉, 룰렛 휠 선택은 [식 1]을 이용하여 [그림 1]과 같은 룰렛을 만들고, 만들어진 룰렛을 이용하여 확률적으로 염색체를 선택하는 것이다. 룰렛 휠 선택을 이용하면, 적합도가 높은 염색체가 더 높은 확률로 선택되도록 설정하는 동시에 염색체들의 다양성도 유지할 수 있다.


3.4. 선택된 염색체들로부터 자손을 생성하는 연산

앞에서 설명한 룰렛 휠 선택 방법을 통해 선택된 두개의 부모 염색체들로부터 하나의 자손 염색체를 생성한다. 유전 알고리즘에서는 자손을 생성하는 연산으로 주로 crossover라는 연산을 이용한다. Crossover 연산을 그림으로 표현하면, 아래의 [그림 2]와 같다.

![image](https://user-images.githubusercontent.com/101514626/173855383-b46df14e-9928-4bb1-961f-7e941f1e7a66.png)

[그림 2] Crossover 연산의 동작.

Crossover 연산에서 염색체를 분할하는 지점인 division point는 임의로 선택된다.


3.5. 돌연변이 (mutation) 연산

만약, 앞에서 설명한 4-3, 4-4와 같은 연산을 이용해서 검색을 진행하면, 유전 알고리즘은 지역 최적점에 도달하게 될 것이다. 유전 알고리즘에서는 지역 최적점에 빠지는 문제를 해결하기 위해 새롭게 생성된 염색체에 확률적으로 돌연변이가 발생하도록 한다. 일반적으로 0.1%, 0.05% 등의 아주 낮은 확률로 돌연변이가 발생하도록 설정하며, 염색체에서 돌연변이를 발생시키는 연산은 매우 다양하다. 예를 들어, [그림 2]에서 생성된 자손에 대해 아래의 [그림 3]과 같은 두 개의 돌연변이 연산을 정의할 수 있다.

![image](https://user-images.githubusercontent.com/101514626/173855748-0d43a27e-553c-4788-a1e2-a726889ae70b.png)

[그림 3] 돌연변이 연산에 대한 두 가지 예시.


[그림 3-a]는 임의로 하나의 유전자를 선택하여 0이면 1로, 1이면 0으로 값을 바꾸는 돌연변이 연산이다. [그림 3-b]는 두 개의 유전자를 임의로 선택하여 두 유전자의 값을 교환하는 돌연변이 연산이다. 돌연변이 연산에는 이외에도 많은 종류가 있으며, 해결하고자 하는 문제에 맞게 돌연변이 연산을 정의하면 된다.


4. 예제 - 유전 알고리즘과 TSP

이 항목에서는 유전 알고리즘을 이용하여 NP-hard에 속하는 대표적인 문제인 TSP (Travelling Salesman Problem)의 최적해를 구해 본다. TSP를 간단히 정의하면 아래와 같다.

• 출발점에서 시작하여 모든 노드를 단 한번만 지나 출발점으로 돌아오는 최단 경로를 구하는 문제

노드가 15개만 있다고 해도 TSP의 완벽한 답을 찾기 위해서는 15!에 해당하는 약 1조 3000천억개의 경우를 계산해야 한다. 따라서, 현실적으로 TSP의 정확한 답을 찾는 것은 불가능하다. 그러나 유전 알고리즘을 이용한다면, 정확한 답은 아니더라도 거리가 일정 수준 이하인 최적의 답은 찾을 수 있다.

이 예제에서는 유전 알고리즘을 이용하여 도시의 수가 5개인 TSP의 최적해를 구할 것이다. 각 도시의 이름과 좌표는 아래와 같으며, 출발 도시는 A이다.


• A (10, 10)

• B (10, 5)

• C (14, 5)

• D (40, 50)

• E (1, 3)


도시의 좌표 정보를 바탕으로 아래의 [그림 4]와 같은 거리 정보 테이블을 구성할 수 있다. 거리 정보 테이블은 염색체의 적합도를 계산할 때 이용되므로, 메모리상에 보관하는 것이 좋다.

![image](https://user-images.githubusercontent.com/101514626/173856247-00cd9b46-df2b-42d1-9676-1fb1dd0e9ea2.png)

[그림 4] 거리 정보 테이블.



그리고 예제의 TSP에 대한 염색체를 아래의 [그림 5]의 좌측과 같이 크기가 4인 배열의 형태로 인코딩할 수 있다 (염색체의 크기가 4라는 것은 유전자가 4개라는 것과 같다). [그림 5]의 우측은 어떠한 염색체 [E C D B]가 의미하는 TSP의 해를 나타낸다. 염색체 [E C D B]는 출발점 A에서 시작하여 E→C→D→B를 거쳐 다시 A로 돌아오는 경로를 의미한다.


![image](https://user-images.githubusercontent.com/101514626/173856337-bc7cc45a-7659-4a1d-89e8-f2460b9bf473.png)

[그림 5] 예제 문제에 대한 염색체 인코딩 (encoding).



또한, 유전 알고리즘의 인자 (parameter)인 한 세대 당 염색체의 수 (population size)는 4로, 돌연변이 확률은 0.1%, 최대 반복 횟수는 1000, 허용 거리는 125으로 설정했다고 가정한다. 그리고 염색체의 적합도 함수는 아래의 [식 2]와 같이 정의한다. [식 2]에서 N은 염색체의 크기이고, $d(A, B)는두도시A와B$의 거리를 구하는 함수이다.

![image](https://user-images.githubusercontent.com/101514626/173856454-6e3e919f-46a3-42e3-ab80-a6303db6ff80.png)


[식 2]는 A에서 염색체에 나타난 첫 번째 도시로 이동할 때의 거리와 염색체에 나타난 순서대로 도시를 이동할 때의 거리, 그리고 염색체의 마지막에 나타난 도시에서 A로 이동할 때의 거리를 합하여 역수를 취하고 있다. 예를 들어, [그림 5]의 염색체에 대해서는 A→E, E→C, C→D, D→B, B→A, 총 5개의 이동에 대해 거리를 계산하여 합산한다. [식 2]에서 역수의 분자에 1000을 설정하고, 제곱을 하는 것은 어떠한 규칙이 아니라, 단순히 경험론적으로 설정한 것이다. 따라서, 실제 구현에서 [식 2]와 똑같이 적합도 함수를 정의할 필요는 없다.

위에서 설정한 알고리즘의 인자 및 적합도 함수와 염색체에 대해 [항목 3]에서 서술한 대로 유전 알고리즘을 동작하면 다음과 같다.


1) 초기 염색체의 집합 생성

초기 염색체 생성 연산에 의해 생성된 염색체들은 아래의 [그림 6]과 같다.

![image](https://user-images.githubusercontent.com/101514626/173856592-6cf7235d-3136-4a5b-b3f8-c8cec32e5f97.png)

[그림 6] 초기 염색체의 집합.



2) 초기 염색체들에 대한 적합도 계산

[그림 6]의 염색체들에 대한 적합도를 계산하면 아래의 [그림 7]과 같다.

![image](https://user-images.githubusercontent.com/101514626/173856676-0a1f2327-5703-4983-b4c1-0b797c28c348.png)

[그림 7] 초기 염색체들에 대한 적합도 계산.


3) 현재 염색체들로부터 자손들을 생성

룰렛 휠 선택 방법을 통해 염색체 [B C E D]와 [D E C B]가 선택되었다고 가정하면, crossover 연산을 통해 [그림 8]과 같은 자손이 생성된다.

![image](https://user-images.githubusercontent.com/101514626/173856777-7a80e5b2-8fe5-4279-9937-99c328f34e87.png)

[그림 8] 두 염색체로부터 자손 생성.




TSP에서는 도시를 한 번만 경유해야 하기 때문에 첫 번째 부모로부터 B C를 받은 경우, 두 번째 부모 염색체에서 C B를 그대로 가져오는 것이 아니라, 중복되지 않은 도시들을 순서대로 가져온다. 따라서, 자손은 [B C C B]가 아니라, [B C D E]가 된다.


Crossover 연산을 통해 성공적으로 자손을 생성하였다면, 확률적으로 새롭게 생성된 자손에 돌연변이를 일으킨다. 유전 알고리즘의 인자를 설정하는 단계에서 돌연변이 확률을 0.1%로 설정하였기 때문에 0.1%의 확률로 새롭게 생성된 자손에 돌연변이가 발생한다. 만약, [그림 8]에서 생성된 자손에 0.1%의 확률로 돌연변이가 발생하였다고 가정하면, [그림 9]와 같은 과정을 통해 새롭게 생성된 자손이 변형된다. 돌연변이 연산은 두 유전자를 임의로 선택하여 교환하는 exchange로 하였다. 따라서, 최종적으로 생성된 자손은 [B E D C]가 된다.


![image](https://user-images.githubusercontent.com/101514626/173856913-b829b009-afe2-4090-b5d3-455b1d6c41cc.png)

[그림 9] 돌연변이 연산.

한 세대 당 염색체의 수를 4로 설정하였기 때문에 [그림 8~9]와 같은 룰렛 휠 선택→crossover→돌연변이의 과정을 3번 더 반복한다.




4) 생성된 자손들의 적합도 계산

앞의 과정을 통해 생성된 4개의 자손에 대해 적합도를 계산하면, 아래의 [그림 10]과 같다.

![image](https://user-images.githubusercontent.com/101514626/173857054-22ea8e20-f86d-4299-ae6e-b647c78ca69e.png)

[그림 10] 새롭게 생성된 자손들에 대한 적합도 계산.


5) 종료 조건 판별

최대 반복 횟수가 1000이고, 적합도가 가장 큰 [C B E D] 염색체의 이동 거리는 약 130으로 목표값인 125보다 크기 때문에 종료 조건 판별 연산에서는 거짓이 반환된다.


6-1) 종료 조건이 거짓인 경우, (3)으로 이동하여 반복

종료 조건 판별 연산에서 거짓이 반환되었으므로, "(3) 현재 염색체들로부터 자손들을 생성"으로 돌아가 알고리즘을 반복한다.







