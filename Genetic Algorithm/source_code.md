#파이썬으로 구현

우선 랜덤으로 최초의 아이들을 생성한다.

그리고 그 생성된 아이들을 가지고 fitness (성능)을 측정한다.

성능을 측정할 때 적절한 점수를 부여하여 만약 점수가 높다면 해당 아이들을 선발해 낸다.

그리고 선발된 아이들을 교배하여 다음 세대를 만들어낸다.

그 과정에서 돌연변이도 추가하여 다음 세대를 만들어 내고 또 태어난 자식들을 가지고 성능을 측정하여

위의 과정을 계속 반복하여 수 세대를 걸쳐서 답을 도출해 내는 것이 유전 알고리즘이다.



우선 비밀번호는 문자열을 사용하고 길이가 최소 2 ~ 최대 10 정도로 적당하게 설정한다.

그리고 랜덤으로 아스키코드의 문자와 숫자를 생성해야 하기 때문에 random과 string을 import 한다.



![image](https://user-images.githubusercontent.com/101514626/173858665-0898d9b9-feab-4357-89f3-02cf107a578e.png)

↓

-------------------------------------------------------------------------------------------------------------------------
import random
import string
-------------------------------------------------------------------------------------------------------------------------


다음은 비밀번호를 길이만큼 랜덤으로 생성하는 함수이다.


![image](https://user-images.githubusercontent.com/101514626/173858364-4884bd81-e70a-4ea7-b20b-22470cc8af0e.png)

↓
-------------------------------------------------------------------------------------------------------------------------
def generate_word(length):
    result = ""
    x = "".join(random.sample(string.ascii_letters + string.digits, k=length))
    return x
-------------------------------------------------------------------------------------------------------------------------



입력값으로 비밀번호의 length를 받아와서 초기 result 값을 빈 문자열로 초기화 한 뒤에

random을 통해서 a~Z까지 0~9에 해당하는 임의의 아스키 문자와 숫자를 길이만큼 조합하여

x에 저장한 후 해당 비밀번호를 리턴해 준다.

![image](https://user-images.githubusercontent.com/101514626/173858795-3316672f-880e-4751-9238-4bf046de5dcb.png)


위와 같이 테스트를 해보면 결과는 다음과 같이 길이가 10인 숫자와 문자가 랜덤으로 생성된 것을 볼 수 있다.


![image](https://user-images.githubusercontent.com/101514626/173858963-cdfc864a-1ee1-43ed-98af-660117c4ddb8.png)

임의의 비밀번호 생성




다음으로 첫 세대를 만들어 보자.


![image](https://user-images.githubusercontent.com/101514626/173859121-b2f2fc6c-a096-4479-b584-6fe21f483979.png)


![image](https://user-images.githubusercontent.com/101514626/173859215-dce56877-6377-4c66-9a64-82cbb852143a.png)


위와 같이 테스트를 진행하여 첫 번째 세대를 찍어보면 결과는 다음과 같다.


![image](https://user-images.githubusercontent.com/101514626/173859301-8ba369a3-9e6d-4898-9be9-e860971579ee.png)

[그림1. 첫 번째 세대]


길이도 각자 다 다르고 숫자와 문자가 잘 섞인 것을 볼 수 있다.



이렇게 만들어진 세대를 가지고 fitness를 측정한다.


![image](https://user-images.githubusercontent.com/101514626/173859523-313dad23-f3e9-47c2-a503-edd57ccd2325.png)


위에서 생성한 비밀번호들을 가지고 초기에 점수를 0으로 초기화 한 뒤 우리가 설정한 비밀번호 password와 test_word를 비교하여 성능을 측정하면 결과로 100점 만점에 몇 점인지 그 비밀번호의 점수가 리턴 된다.

처음 분기문에서 비밀번호의 길이 자체가 다르면 다른 비밀번호이기 때문에 그냥 0점을 반환해버린다.



그런데 만약 test_word와 비밀번호의 길이가 같다면 0.5점을 더해준다.

그리고 그 아래 반복문에서는 비밀번호와 직접 요소 하나하나를 돌면서 문자열이 있으면 1점을 계속 더해준다.



실제로 어떻게 측정이 되는지 테스트를 해보자.

그렇게 해서 성능이 측정되어진다.

![image](https://user-images.githubusercontent.com/101514626/173859777-b3cbc5ff-3029-4566-bbcb-a98ce31caa04.png)


이렇게 함수를 호출하면서 첫 번째 인자에는 우리가 설정한 비밀번호, 두 번째 인자로는 test_word인

예측한 비밀번호가 들어가게 된다. 그럼 결과는 81.81점이 나온다.



다음으로는 compute_performance라는 함수이다.

이 함수는 위에서 만든 성능 측정 함수를 이용하여 태어난 자식들의 점수를 측정하여 비밀번호의 길이를 예측하는 함수이다. 그리고 점수를 내림차순으로 정렬한다.


![image](https://user-images.githubusercontent.com/101514626/173859971-3307bc72-807d-417d-af6a-6b95fa0ecb06.png)


반환 값으로는 점수로 정렬된 아이들의 리스트와 비밀번호의 예상 길이가 리턴 된다.

 

다음 함수는 이렇게 계산된 아이들 중 살아남을 아이들을 선택하는 함수이다.

![image](https://user-images.githubusercontent.com/101514626/173860101-4b6d1c37-998e-44fe-97c4-07abff20f5f8.png)



위의 두 함수를 아래의 코드로 테스트해보자.


![image](https://user-images.githubusercontent.com/101514626/173860197-9882e96f-6203-4950-b940-d4eeaa45fd62.png)



![image](https://user-images.githubusercontent.com/101514626/173860226-c409313c-7005-43e6-bd2e-50325da52b2e.png)


가장 첫 줄에 비밀번호가 생성되고

다음 리스트에는 비밀번호의 길이를 맞춘 아이들이 보이고 해당 점수가 높은 아이들부터 정렬되는 것이 보인다. 첫 세대에 14점이나 획득했다는 것을 알 수 있다.

그리고 이를 통해서 비밀번호가 10자리 인 것도 알아냈다.

그리고는 살아남은 아이들에 대한 결과가 출력되어진 것을 볼 수 있다. 보면 아예 터무니없는 아이들이 거의 사라진 결과를 알 수 있었다.



다음 함수는 위의 마지막 결과처럼 살아남은 아이들을 가지고 교배시키는 함수이다.


![image](https://user-images.githubusercontent.com/101514626/173860369-ce86e85e-62b6-4415-ab6a-00066ccd7354.png)


살아남은 아이들을 가지고 적절히 나눠 가지면서 새로운 아이들을 만들어 낸다. 그리고 만들어낸 아이들을 다음 세대로 보내는 과정이다.

 

위의 함수를 테스트하여 자식들을 출력해 보자.

![image](https://user-images.githubusercontent.com/101514626/173860454-2cbaad3a-8e98-4137-b5d6-3286bceb7c64.png)


![image](https://user-images.githubusercontent.com/101514626/173860480-c18efa9b-fe83-4c74-833e-9ce2f28fb933.png)


구분선을 추가하여 좀 보기 쉽게 출력해 보았다.



다음 함수로는 돌연변이를 생성하여 다음 세대에 추가하는 함수이다. 이 돌연변이를 통해서 비밀번호의 예측을 한 번에 끌어올릴 수 있도록 한다.


![image](https://user-images.githubusercontent.com/101514626/173860570-8fd64df3-960f-4d59-be99-d3c8ae4847c1.png)



위의 함수들을 가지고 이제 메인에서 내가 비밀번호를 설정하고 옵션들을 설정하여 몇 세대만에 내가 설정한 비밀번호를 맞추는지 알아보자.


![image](https://user-images.githubusercontent.com/101514626/173860683-df1bc7ae-1135-4c19-bf40-da75501c3715.png)


출력 결과로는 항상 가장 점수가 높은 아이만 출력하고 그 아이의 점수와 그 아이가 몇 세대인지만 출력해서 결과를 보면 아래와 같다.


![image](https://user-images.githubusercontent.com/101514626/173860778-9b1af385-65c4-4c29-b846-6f87b86330b5.png)


총 237 세대만에 내가 초기에 설정한 비밀번호를 맞춰낸 모습을 볼 수 있다.

그렇지만, 실제로 이 알고리즘으로 비밀번호를 찾아낸다면?

-> 최대 횟수 제한이 걸려있으므로 불가능하다.
